\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{todonotes}

% \usepackage{fancyhdr}
% \usepackage{graphicx}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.95}

\usepackage{geometry}
\geometry{legalpaper, margin=1in}

\title{VT Good Image Protocol \\
a standardization proposal}
\author{Christian Parpart}
\date{2020-12-13 (draft, revision 0)}

\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\newcommand{\DA}{\code{DA}}
\newcommand{\DECRQM}[1]{\code{CSI ? #1 \$ p}}
\newcommand{\DECRST}[1]{\code{CSI ? #1 l}}
\newcommand{\DECSET}[1]{\code{CSI ? #1 h}}

\newcommand{\GoodImageProtocol}{\code{Good Image Protocol}}

\begin{document}

\maketitle

\tableofcontents

%\newpage

\section{Motivation} % {{{

For many decades Sixel and ReGIS have been the only image protocols for VTs. While both are
ancient and not even widely implemented, newer generations of people are used to seeing images
and even emojis everywhere. Those people may eventually touch a virtual terminal emulator
and expect to be it no different than what they are used to in other software systems.

There is growing interest in both of these fields, and thus, many virtual terminal emulator
developers, 30 to 40 years later, have started implementing their own proprietary protocols
for displaying images as Sixel was simply not state of the art anymore.

While this is positive, it also leads to fragmentation in the ecosystem because application
developers do not know what to support in case they intend display images.
This specification attempts to unify all those image protocols - not as a superset, but rather
as a largest common denominator, with implementation adaptability on both ends - terminal and
application side.

% }}}
\section{Requirements} % {{{

\begin{enumerate}
    \item Headless, multi-headed.
    \item Deterministic emulation.
    \item Grid cells as the only unit size except for the actual image to be uploaded
    \item Remote-terminal capable (no dependency on the local host, such as the local file system)
    \item Synchronous operations only (no asynchronous operations unless explicitly requested)
    \item Aspect ratio must be kept by default (and support customization)
    \item Image upload must be decoupled from image display
    \item Ability to render sub-rectangles of the uploaded image
    \item Future-reusability of uploaded images for other uses (such as
        icon-display, desktop-notifications, background images)
\end{enumerate}

\paragraph*{}

The document at \ref{ref:twg-gip} suggests cell based masking for rendering to help rendering more
complex scenes such as in windowed TUI applications or terminal multiplexers.
However, the same can be achieved with a sequence of Image-Render commands specifying a
sub-rectangle to be rendered of the referenced image.

% }}}
\section{Prior art and current state} % {{{

Prior art of image protocols for terminals are as follows:

\subsection{DEC ReGIS graphics}

\begin{itemize}
    \item First appeared in 1981
    \item vector graphics based
    \item implemented by: xterm
\end{itemize}

\subsection{Sixel graphics}

\begin{itemize}
    \item Sixel grpahics first appeared in VT330/VT340 specifications that seems to be published in 1988.
    \item It is pixel based and positions the graphics cursor in a way it is most optimal for dot printers,
        that could print 6 pixels in height per line.
    \item Specialized image format optimized for 6-pin printers.
    \item implemented by: xterm, mlterm, wezterm, contour, VTE
\end{itemize}

\subsection{iTerm2 image protocol}

\begin{itemize}
    \item Can associate a file name (Base64 encoded) to the rendered image.
    \item Image display size can be pixel based as well as cell based.
    \item Also has the ability to address the with and hight relative to the terminal window size.
    \item Image data is Base64 encoded.
\end{itemize}

\todo{When was iTerm2 image protocol first introduced?}
\todo{iTerm2 supported image formats?}

\subsection{Terminology image protocol}

\begin{itemize}
    \item First appeared in ... \todo{When did Terminology's image protocol first appear?}
    \item Very hard to find anything out about the underlying transmission protocol.
    \item Seems to be file based.
    \item No specification available.
\end{itemize}

\subsection{Kitty image protocol}

\begin{itemize}
    \item First appeared in 2017
    \item Seperates image upload from image display
    \item Can mandate image sizes in pixels as well as in grid cell dimensions.
    \item Images are rendered independantly of text with a specified Z-axis.
    \item Images can be deleted without knowning their names but only by specifying X/Y/Z axis
          and delete all images intersecting these criteria.
    \item Image formats supported are: RGB, RGBA, PNG.
    \item Image data is Base64 encoded.
    \item Supports optionally compressing the image data.
    \item Supports various image data transmission methods:
        \begin{itemize}
            \item inline, as part of the VT sequence
            \item named shared memory
            \item path to local files
        \end{itemize}
    \item Optionally deletes the local file when requested and the file path is in a secure location.
    \item Hard coded image storage pool to 320 MB (per screen buffer).
\end{itemize}

% }}}
\section{Backwards Compatibility} % {{{

Since all other image protocols are pixel based, the proposed image protocol does not
attempt to retain any backwards compatibility. Instead, the goal is to create
an image protocol that is future proof with todays needs in mind.

% }}}
\section{Future Compatibility and Stability} % {{{

In order to leave room for improvements, the VT sequences should be designed in a way
that allows specifying additional parameters in the future, and simultaneously ensures
that older implementations can still work while safely ignoring any new parameters.

% }}}
\section{Terminal Emulator Requirements} % {{{

This is the list of resource requirements that must be guaranteed by the virtual terminal emulator.

\begin{enumerate}
    \item at least 32 images displayable concurrently
    \item at least 4 MB per image uncompressed
    \item at least 128 MB per storage pool (\(4 * 32\))
\end{enumerate}

Upper limits must be present for security reasons but can be varying by implementation.

\todo{Have the ability to query resource limits?}
\todo{What should happen when the number of images an application wants
      to display is higher than the limit?}

% }}}
\section{Performance Considerations} % {{{

TBD.

% }}}
\section{Security Considerations} % {{{

\begin{itemize}
    \item image upload spamming
    \item huge image Uploads
    \item invalid image Uploads
    \item invalid image render requests (such as out of bounds in offsetted-renders)
\end{itemize}

% }}}
\section{Semantics} % {{{

\subsection{Upload Image}

Uploads an image for future render operations.

\begin{itemize}
    \item Id; a unique identifier for the uploaded image
    \item format; a value that determines the image format. See section \ref{sec:supported-image-formtats}
    \item data; image data in the given input format
    \item width; optional pixel width of the given image (only required for RGB/RGBA format)
    \item height; optional pixel height of the given image (only required for RGB/RGBA format)
\end{itemize}

\subsubsection{Idempotency}

Image upload can be implemented to be idempotent, i.e. the storage pool keeps an internal hash
of each image that is automatically constructed upon image upload.
If the image was already uploaded, that image's reference count is incremented
and in case it is a named resource, that one will point to that existing one.

\subsubsection{Storage Management}

Uploaded images are reference counted. Uploading a named image will initialize its reference count to 1.

When uploading an image would exceed the storage pool's guarantees,
the host may choose to actively evict older images in either priority:

\begin{enumerate}
    \item oldest first, or
    \item least reference counted (in visible area) first.
\end{enumerate}

Evicted images that were still held in grid cells may display a unicode object replacement
codepoint (U+FFFC) or an empty cell.

Displaying an image results in incrementing the reference counter by the number of grid cells
that are holding parts of the image.

Clearing a grid cell holding an image fragment (e.g. by overwriting or deleting its contents)
will decrement the image reference counter.

When no grid cell is holding a reference to the image,
the corresponding reference counter should be either 1 (if uploaded in a separate step)
or 0 (if uploaded within the render instruction).

Releasing the image by its Id will simply decrement its reference counter.

\subsection{Render Image}

Renders an image that has either been previously uploaded and thus is being referenced
with a unique Id, or with the image data provided inline.

Providing an upload Id along with inline image data is invalid.

\begin{itemize}
    \item Id; unique identifier referencing a previously uploaded image
    \item grid-width; number of grid cells to render horizontally
    \item grid-height; number of grid cells to render vertically
    \item resizePolicy; optional, mandates how to resize the image within the grid cells (default NoResize)
    \item alignmentPolicy; optional, mandates how to align the image within the grid cells (default: MiddleCenter)
    \item image-x-offset; optional, start rendering at the given pixel x-offset cell of the image (default 0)
    \item image-y-offset; optional, start rendering at the given pixel y-offset cell of the image (default 0)
    \item image-width; optional, number of pixels of the image's width to display (default: max width)
    \item image-height; optional, number of pixels of the image's height to display (default max height)
    \item status: optional, request a success/failure status response code from the terminal, by default
        no status result will be sent back to the client application.
        The response status code can be one of the following:
        \begin{itemize}
            \item Success
            \item Image Not Available (has never been or was removed actively or by the garbage collector)
        \end{itemize}
\end{itemize}

\subsection{Upload and Render Image}

An image can be uploaded and rendered within a single instruction.
The image is being released automatically right after and therefore cannot be referenced
again.

The parameters of this function is the sum of the image upload and image render parameters excluding the unique
identifier.

\subsection{Release Image}

Dereferences the use-count of a previously uploaded image.

\begin{itemize}
    \item Id; Unique identifier referencing a previously uploaded image.
\end{itemize}

\subsection{Feature Detection}

\DA is already used to advertise terminal features, including sixel graphics, and thus,
could be used to also advertise the availability of \GoodImageProtocol.

There is some improved feature detection specification work ongoing,
so there may be other ways to detect \GoodImageProtocol in the future, when that is ready.

\subsection{Interoperability with other VT sequences}

\subsubsection*{Clearing the grid}

VT sequences (such as \code{CSI Ps J}) that reset the textual contents of the grid cells will also
clear their image fragment referencing an underlying image, possibly also releasing the
underlying image(s) from the image storage pool when their reference count goes to zero.

\subsubsection*{Primary and alt screen}

Alt screen and primary screen maintain both their own image storage pool.

When leaving the alt screen, its image storage pool gets cleared.
% }}}
\section{Syntax} % {{{

This section maps each semantic action to actual VT sequences.

\subsection{Upload Image}

Syntax: \code{DCS id:ID ; fmt:ID ; u payload ST}

\begin{tabular}{ |c|c|l| }
    \hline
    parameter   & Key & Value \\
    \hline
    Id          & 1   & UInt32 \\
    fmt         & 2   & enum (see section \ref{sec:supported-image-formtats}) \\
    width       & 3   & Uint32 \\
    height      & 4   & Uint32 \\
    \hline
\end{tabular}

The payload's format is mandated by the \code{fmt}'s value. However, since it must not contain
any C0 or C1 escape codes, the transport is further protected by encoding it via Base64.

\subsection{Render Image}

Syntax: \code{DCS id:ID ; x:NUM ; y:NUM ; w:NUM ; h:NUM ; resize:RESIZE ; alignment:ALIGNMENT ; status:VAL r ST}

\begin{tabular}{ |c|c|l| }
    \hline
    parameter   & Key & Value \\
    \hline
    Id          & 1   & UInt32 \\
    x           & 2   & UInt32 \\
    y           & 2   & UInt32 \\
    width       & 3   & UInt32 \\
    height      & 4   & UInt32 \\
    resize      & 5   & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    alignment   & 6   & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
                &     & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
                &     & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    reqStatus   & 7   & 0 (Success), 1 (Image not available) \\
    \hline
\end{tabular}

\paragraph*{}

When a response status code was requested, the syntax will be as follows:

\begin{tabular}{ |r|l| }
    \hline
    \textbf{VT sequence} & \textbf{description} \\
    \hline
    \code{CSI > 0 i} & Image is rendered successfully \\
    \code{CSI > 1 i} & Image was not rendered. No image with the given Id found. \\
    \hline
\end{tabular}

\subsection{Upload and Render Image}

Syntax: \code{DCS id:ID ; x:NUM ; y:NUM ; w:NUM ; h:NUM ; resize:RESIZE ; alignment:ALIGNMENT s payload ST}

\subsection{Release Image}

Syntax: \code{DCS id:ID d ST}

\begin{tabular}{ |c|c|l| }
    \hline
    parameter   & Key & Value \\
    \hline
    Id          & 1   & UInt32 \\
    \hline
\end{tabular}

\subsection{Feature Detection}

Syntax: \DA

\DA's response code for detecting support for an implementation of this specification is 11

% }}}
\section{Support Image Formats} % {{{

\label{sec:supported-image-formtats}

\begin{tabular}{c | c | l}
    File Format & Identifier & Description \\ \hline
    RGB & 1 & raw RGB data with each color component being of size 1 byte. \\
    RGBA & 2 & raw RGBA data, just like RGB, but with an alpha channel. \\
    PNG & 3 & PNG file format \\
\end{tabular}

% }}}
\section{References} % {{{

\begin{enumerate}
    \item \label{ref:ctlseqs}https://invisible-island.net/xterm/ctlseqs/ctlseqs.txt
    \item \label{ref:twg-simple-image-display}Simple Image display, https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/12
    \item \label{ref:twg-gip}Good Image Protocol, https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/26
    \item \label{ref:image-sixel}Sixel Image Protocol, https://vt100.net/docs/vt3xx-gp/chapter14.html
    \item \label{ref:image-item2}iTerm2's image protocol, https://iterm2.com/documentation-images.html
    \item \label{ref:image-terminology}Terminology's image protocol, https://www.enlightenment.org/docs/apps/terminology.md \todo{Terminology image protocol spec not found. ;-(}
    \item \label{ref:image-kitty}Kitty's image protocol, https://sw.kovidgoyal.net/kitty/graphics-protocol.html
\end{enumerate}
% }}}

\section{Editorial Notes}
\listoftodos

\end{document}

% vim:ts=4:sw=4
